HOW TO PLAY

We play a game "Guess my number". The rules are simple. You write a number with
5 digits with unique figures. You make a guess and your opponent gives you two 
feedbacks: how many figure are in place and how many figure are out place. For 
exemple: Your opponent's number is 30827 and your guess is 40276. Than your opponent 
response is +1 (2nd digit 0 is in place) -2 (2 and 7 are in my number but location 
is different). This cycle is repeated respectively untill one of the player 
make a correct guess.

CHALLANGE

How fast can my algorithm make a correct guess? 

ARCHITECTURE
Three parent child class created. In order:
    FiveDigit
    Guess
    Iterate
    
FiveDigit object has one atribute in strings: five digit number

Guess object has three attributes; figure, heritaded 
from parent class FiveDigit and two news: in_place and 
out_place. It has also procedures to return in_place and out place attributes.

Iterate object has an attribute; guess_list. 
Inherits from Guess
Main procedure of Iterate are explained in part ALGORITHM

ALGORITHM

First guess is completely random. From second guess algorithm interven:
It takes the information of the first guess. How many digits are in place(ex: +1), 
how many digits are out place (ex: -2). It begins by in place information; select 
randomly equivalent of in place digit from first guess; similarly does for out place.
For the residual digits, ones again it tosses random digits.

At the end of every stage a variable (list) called "possible" is updated. Possible stores
figures allowed for a given position. The procedure is called:
    Iterate.possible_digits_in_index(possible)
     
At the very beginning all figures are allowed for all digits. 
The procedure removes figures in two case:
    if in place is 0, it means that non of the figures are in place.
    if in place of previous guess  is greater than 0 and the one of the last guess is 0; 
    than the guess for in place position(s) are missed.
    
New guess is choosen from guesses that fits the best for the previous guesses. For a 
potential guess a score is calculated with a procedure called:
    Iterate.compare_as_if(self,new_guess)
    
    The procedure based on the idea that if you make a good guess it should give you exactly
    the same score in place and out place for the previous guesses. So the more guesses you 
    have, the more the probability of guessing the correct number. 

The number of potential guess is determined by "episode". A new guess is created by a 
procedure called:
    Itearte.iterate_w_in_place_out_place(self,possible,episode)
    
THE RESULTS

In the project folder you will find two csv files generated by a prosedure called:
    Iterate.simulate(sample,start,stop,step)
    start, stop are corresponding to various episodes
    
    df_gt_100_lt_200.csv is generated with 250 samples, episode between 100 and 190 with
    step 10.
    
    df_50_300_by_50.csv is generated with 200 samples, episode between 50 and 250 with
    step 50.
    
    I voluntariliy selected the second outcome to illustrate the relation of the number of 
    trials to succed and the number of episode. Please find the box plot in 
        simulation.pdf
    
    Number of trials to succed converges to 6 with a moderate episodes.

CONCLUSION

As the number of predictions increases, the algorithm might end up with a bug. It occurs in:
    util.clean_up_and_guess(in_place_dict,out_place_dict,possible,last_guess_figure)
    
    while predicting the residual digits. You might end up with an empty list in temp_possible
        temp_char = str(random.sample(temp_possible[index],1)[0])
        
    In order to keep the simple way I voluntariliy fixed the bug on the except bloc
    
If you run main.py it simulates one by one a prediction loop untill success.
    
 

